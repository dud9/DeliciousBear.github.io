<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Thread - 多线程学习</title>
    <link href="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<hr><p>基础回顾</p><span id="more"></span><h1 id="一-基础部分"><a href="#一-基础部分" class="headerlink" title="一. 基础部分"></a>一. 基础部分</h1><h2 id="Thread的实现方式"><a href="#Thread的实现方式" class="headerlink" title="Thread的实现方式"></a>Thread的实现方式</h2><h3 id="1-Thread类"><a href="#1-Thread类" class="headerlink" title="1.Thread类"></a>1.Thread类</h3><ul><li><p>继承Thread类, 并重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br><br>    <span class="hljs-comment">// main 线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test01 t = <span class="hljs-keyword">new</span> Test01();<br>        t.start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>生成对象并调用start方法</p></li></ul><h3 id="2-实现Runnable-接口"><a href="#2-实现Runnable-接口" class="headerlink" title="2.实现Runnable 接口"></a>2.实现Runnable 接口</h3><ul><li>实现runnable接口, 生成Thread对象,调用start方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Test02());<br>        t.start();<br>    &#125;<br>&#125;   <br></code></pre></td></tr></table></figure><ul><li>利用lamda表达式简化代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//        Thread t = new Thread(new Test02());</span><br><span class="hljs-comment">//        t.start();</span><br>        <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a>3. 实现Callable接口</h3><p><font color="red"><strong>可以获得返回值</strong></font></p><p>需要搭配 future 来使用</p><p>实现 callable接口 重写 call() 方法 配合 线程池的submit方法()</p><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/callable.png" alt="Callable"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liu yicheng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/6/18 - 20:27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test03</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        Test03 t = <span class="hljs-keyword">new</span> Test03(<span class="hljs-string">&quot;Thread-01&quot;</span>);<br>        ExecutorService e = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>        Future&lt;String&gt; future = e.submit(t);<br><span class="hljs-comment">// 使用 lamda 表达式</span><br>        Future&lt;String&gt; future1 = e.submit(() -&gt; Thread.currentThread().getName());<br><br>        String s = future.get();<br>        System.out.println(s);<br>        e.shutdown();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-本质"><a href="#4-本质" class="headerlink" title="4. 本质"></a>4. 本质</h3><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/thread.png" alt="thread"></p><p><font color="red"><strong>Thread 类继承了 Runnable接口</strong></font></p><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/runnable.png" alt="runnable.png"></p><p><strong>线程执行都是运行Runnable 中的 Run()方法,而线程要执行得先进入就绪态,等待获取cpu使用权,也就是执行Thread类中的start()方法</strong></p><p>方法一的本质就是调用start方法,而新生成的类继承了Thread类,也就继承了start()方法,执行start后就入就绪态,获得cpu后,执行run方法;</p><p>方法二,虽然实现了runnable接口,但是执行run方法,要进入就绪态,就必须调用Thread类的start方法,所以new 了一个Thread对象,</p><p>Thread的构造方法可以传入一个Runnable接口,执行完start方法后,会执行传入runnable接口的run方法</p><h1 id="二-进阶"><a href="#二-进阶" class="headerlink" title="二.  进阶"></a>二.  进阶</h1><h3 id="1-三种线程池"><a href="#1-三种线程池" class="headerlink" title="1. 三种线程池"></a>1. 三种线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 固定个数的线程池</span><br>ExecutorService e = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 延迟执行线程池</span><br>ExecutorService e1 = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 可以缓存的线程池</span><br>ExecutorService e2 = Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></p><h3 id="2-线程的五个状态"><a href="#2-线程的五个状态" class="headerlink" title="2. 线程的五个状态"></a>2. 线程的五个状态</h3><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/5%E4%B8%AA%E7%8A%B6%E6%80%81(1).png"></p><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/5%E4%B8%AA%E7%8A%B6%E6%80%81(2).png"></p><h3 id="3-线程的主要方法"><a href="#3-线程的主要方法" class="headerlink" title="3. 线程的主要方法"></a>3. 线程的主要方法</h3><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/method.png"></p><h4 id="1-Sleep"><a href="#1-Sleep" class="headerlink" title="(1) Sleep"></a>(1) Sleep</h4><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/sleep.png"></p><p><font color="red"><strong>Sleep 与 wait 的区别就是 sleep 不会释放锁. 而wait会</strong></font></p><h4 id="2-yield"><a href="#2-yield" class="headerlink" title="(2) yield"></a>(2) yield</h4><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/yield.png"></p><h4 id="3-Join"><a href="#3-Join" class="headerlink" title="(3) Join"></a>(3) Join</h4><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/join.png"></p><h3 id="4-线程优先级"><a href="#4-线程优先级" class="headerlink" title="4. 线程优先级"></a>4. 线程优先级</h3><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/priority.png"></p><h3 id="5-守护线程"><a href="#5-守护线程" class="headerlink" title="5. 守护线程"></a>5. 守护线程</h3><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/daemon.png"></p><p><font color="red"><strong>线程分为 用户线程 和 守护线程</strong></font></p><p><strong>虚拟机需要等待用户线程全部执行结束,才会停止运行</strong></p><p><strong>当用户线程执行完毕后, 虚拟机就会停止,而不会等待守护线程执行完毕</strong></p><h3 id="6-线程同步"><a href="#6-线程同步" class="headerlink" title="6. 线程同步"></a>6. 线程同步</h3><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/syn.png"></p><ul><li><p>同步方法</p><p>默认上锁的对象为this  </p></li><li><p>同步代码块</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// list 为需要上锁的对象</span><br>synchronized (<span class="hljs-built_in">list</span>) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; <span class="hljs-built_in">list</span>.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>)).start<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-线程死锁"><a href="#7-线程死锁" class="headerlink" title="7. 线程死锁"></a>7. 线程死锁</h3><p>死锁就是多个线程相互占有对方需要的资源,需要对方占有的资源,却占有对方需要的资源,形成闭环</p><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6.png"></p><h3 id="8-锁-Lock"><a href="#8-锁-Lock" class="headerlink" title="8. 锁 Lock"></a>8. 锁 Lock</h3><h4 id="1-可重入锁-ReentrantLock"><a href="#1-可重入锁-ReentrantLock" class="headerlink" title="(1) 可重入锁 ReentrantLock"></a>(1) 可重入锁 ReentrantLock</h4><p><font color="red"><strong>某个线程已经获得某个锁，可以再次获取锁而不会出现死锁</strong></font></p><p><strong>允许同一个线程多次获取同一把锁</strong></p><p><font color="red"><strong>ReentrantLock</strong></font> <strong>和</strong> <font color="red"><strong>synchronized</strong></font> <strong>都是可重入锁</strong></p><h4 id="2-乐观锁和悲观锁"><a href="#2-乐观锁和悲观锁" class="headerlink" title="(2) 乐观锁和悲观锁"></a>(2) 乐观锁和悲观锁</h4><p>锁的一种宏观分类方式是<strong>悲观锁</strong>和<strong>乐观锁</strong>。悲观锁与乐观锁<strong>并不是特指某个锁</strong>（Java中没有哪个Lock实现类就叫PessimisticLock或OptimisticLock），而是在并发情况下的两种不同策略。</p><p>悲观锁（Pessimistic Lock）, 就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放。</p><p>乐观锁（Optimistic Lock）, 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以<strong>不会上锁，不会上锁！</strong>但是如果想要更新数据，则会在<strong>更新前检查在读取至更新这段时间别人有没有修改过这个数据</strong>。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）。</p><p><strong>悲观锁阻塞事务，乐观锁回滚重试</strong>，它们各有优缺点，不要认为一种一定好于另一种。像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行重试，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p><p>说到乐观锁，就必须提到一个概念：<strong>CAS</strong></p><p>什么是CAS呢？Compare-and-Swap，即<strong>比较并替换，</strong>也有叫做Compare-and-Set的，<strong>比较并设置</strong>。</p><p>1、比较：读取到了一个值A，在将其更新为B之前，检查原值是否仍为A（未被其他线程改动）。</p><p>2、设置：如果是，将A更新为B，结束。[<a href="https://zhuanlan.zhihu.com/p/71156910#ref_1">1]</a>如果不是，则什么都不做。</p><p>上面的两步操作是原子性的，可以简单地理解为瞬间完成，在CPU看来就是一步操作。</p><p>有了CAS，就可以实现一个<strong>乐观锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">data = <span class="hljs-number">123</span>; <span class="hljs-comment">// 共享数据</span><br><br><span class="hljs-comment">/* 更新数据的线程会进行如下操作 */</span><br>flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (flag) &#123;<br>    oldValue = data; <span class="hljs-comment">// 保存原始数据</span><br>    newValue = doSomething(oldValue); <br><br>    <span class="hljs-comment">// 下面的部分为CAS操作，尝试更新data的值</span><br>    <span class="hljs-keyword">if</span> (data == oldValue) &#123; <span class="hljs-comment">// 比较</span><br>        data = newValue; <span class="hljs-comment">// 设置</span><br>        flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 结束</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 啥也不干，循环重试</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">   很明显，这样的代码根本不是原子性的，</span><br><span class="hljs-comment">   因为真正的CAS利用了CPU指令，</span><br><span class="hljs-comment">   这里只是为了展示执行流程，本意是一样的。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这是一个简单直观的乐观锁实现，它允许多个线程同时读取（因为根本没有加锁操作），但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试。 CAS利用CPU指令，从硬件层面保证了操作的原子性，以达到类似于锁的效果。</p><p><img src="https://pic3.zhimg.com/80/v2-3c683e1f88faa31152fc35d14b8fb8de_720w.jpg" alt="img">Java中真正的CAS操作调用的native方法</p><p>因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为<strong>无锁编程</strong>。换句话说，乐观锁其实不是“锁”，它仅仅是一个循环重试CAS的算法而已！</p><h3 id="9-生产者和消费者问题"><a href="#9-生产者和消费者问题" class="headerlink" title="9. 生产者和消费者问题"></a>9. 生产者和消费者问题</h3><p><font color="red"><strong>线程通信问题</strong></font></p><p><font color="red"><strong>Obeject类</strong></font> 提供了一些方法</p><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.png" alt="线程通信"></p><p><font color="red"><strong>重要:</strong></font> 上述方法只能在 「同步方法 」或者 「同步代码块」中使用 </p><ul><li><p>方法一: <font color="red"><strong>管程法</strong></font></p><p><img src="/2021/06/27/Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E7%AE%A1%E7%A8%8B%E6%B3%95.png"></p><p>tips: 利用缓冲区解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        SynContainer container = <span class="hljs-keyword">new</span> SynContainer();<br>        <span class="hljs-keyword">new</span> Productor(container).start();<br>        <span class="hljs-keyword">new</span> Consumer(container).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynContainer</span> </span>&#123; <span class="hljs-comment">// 「缓冲区」</span><br>    <span class="hljs-keyword">int</span> N = <span class="hljs-number">10</span>; <span class="hljs-comment">// 缓存区容量</span><br>    Product[] products = <span class="hljs-keyword">new</span> Product[N];<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 产品计数器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Product product)</span> </span>&#123; <span class="hljs-comment">// 生产者 生产产品</span><br>        <span class="hljs-keyword">if</span> (cnt == N) &#123; <span class="hljs-comment">// 缓冲区满了, 需要通知生产者等待,消费者进行消费</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.notifyAll();<br>        products[cnt++] = product;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Product <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 缓冲区没有产品, 需要通知生产者生产,消费者进行等待</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.notifyAll();<br>        <span class="hljs-keyword">return</span> products[--cnt];<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123; <span class="hljs-comment">// 产品</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Productor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123; <span class="hljs-comment">// 生产者</span><br>    SynContainer container;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Productor</span><span class="hljs-params">(SynContainer container)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.container = container;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            container.push(<span class="hljs-keyword">new</span> Product(i));<br>            System.out.println(<span class="hljs-string">&quot;生产第&quot;</span> + i + <span class="hljs-string">&quot;个产品&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123; <span class="hljs-comment">// 生产者</span><br>    SynContainer container;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(SynContainer container)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.container = container;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            Product pop = container.pop();<br>            System.out.println(<span class="hljs-string">&quot;消费了第&quot;</span> + pop.id + <span class="hljs-string">&quot;个产品&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法二: <font color="red"><strong>信号灯法 「标志位 」</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>&#123; <span class="hljs-comment">// 信号灯法 「标志位」</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TV tv = <span class="hljs-keyword">new</span> TV();<br>        <span class="hljs-keyword">new</span> Player(tv).start();<br>        <span class="hljs-keyword">new</span> Audience(tv).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TV</span> </span>&#123;<br>    String perfermance;<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * flag 为 true 演员表演</span><br><span class="hljs-comment">     * flag 为 false 观众观看</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String perfermance)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!flag) &#123; <span class="hljs-comment">// 演员等待</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.perfermance = perfermance;<br>        System.out.println(<span class="hljs-string">&quot;演员表演了-&quot;</span> + perfermance);<br><br>        flag = !flag; <span class="hljs-comment">// 唤醒观众</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">watch</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123; <span class="hljs-comment">// 观众等待</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;观众观看了-&quot;</span> + perfermance);<br><br>        flag = !flag; <span class="hljs-comment">// 唤醒演员</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    TV tv;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">(TV tv)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tv = tv;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                tv.play(<span class="hljs-string">&quot;斗罗大陆第&quot;</span> + (i / <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;集&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tv.play(<span class="hljs-string">&quot;斗破苍穹第&quot;</span> + ((i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;集&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Audience</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    TV tv;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Audience</span><span class="hljs-params">(TV tv)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tv = tv;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            tv.watch();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode打卡之双向BFS</title>
    <link href="/2021/06/26/LeetCode%E6%89%93%E5%8D%A1%E4%B9%8B%E5%8F%8C%E5%90%91BFS/"/>
    <url>/2021/06/26/LeetCode%E6%89%93%E5%8D%A1%E4%B9%8B%E5%8F%8C%E5%90%91BFS/</url>
    
    <content type="html"><![CDATA[<hr><p>6月25日 <a href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁</a></p><p>6月26日 <a href="https://leetcode-cn.com/problems/sliding-puzzle/">773. 滑动谜题</a></p><span id="more"></span><p>这两题都可以用双向BFS</p><h3 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752.打开转盘锁"></a>752.打开转盘锁</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs clean">你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有<span class="hljs-number">10</span>个数字： <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span> 。每个拨轮可以自由旋转：例如把 <span class="hljs-string">&#x27;9&#x27;</span> 变为 <span class="hljs-string">&#x27;0&#x27;</span>，<span class="hljs-string">&#x27;0&#x27;</span> 变为 <span class="hljs-string">&#x27;9&#x27;</span> 。每次旋转都只能旋转一个拨轮的一位数字。<br><br>锁的初始数字为 <span class="hljs-string">&#x27;0000&#x27;</span> ，一个代表四个拨轮的数字的字符串。<br><br>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。<br><br>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <span class="hljs-number">-1</span> 。<br><br> <br>示例 <span class="hljs-number">1</span>:<br><br>输入：deadends = [<span class="hljs-string">&quot;0201&quot;</span>,<span class="hljs-string">&quot;0101&quot;</span>,<span class="hljs-string">&quot;0102&quot;</span>,<span class="hljs-string">&quot;1212&quot;</span>,<span class="hljs-string">&quot;2002&quot;</span>], target = <span class="hljs-string">&quot;0202&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<br>可能的移动序列为 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;1000&quot;</span> -&gt; <span class="hljs-string">&quot;1100&quot;</span> -&gt; <span class="hljs-string">&quot;1200&quot;</span> -&gt; <span class="hljs-string">&quot;1201&quot;</span> -&gt; <span class="hljs-string">&quot;1202&quot;</span> -&gt; <span class="hljs-string">&quot;0202&quot;</span>。<br>注意 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;0001&quot;</span> -&gt; <span class="hljs-string">&quot;0002&quot;</span> -&gt; <span class="hljs-string">&quot;0102&quot;</span> -&gt; <span class="hljs-string">&quot;0202&quot;</span> 这样的序列是不能解锁的，<br>因为当拨动到 <span class="hljs-string">&quot;0102&quot;</span> 时这个锁就会被锁定。<br>示例 <span class="hljs-number">2</span>:<br><br>输入: deadends = [<span class="hljs-string">&quot;8888&quot;</span>], target = <span class="hljs-string">&quot;0009&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>把最后一位反向旋转一次即可 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;0009&quot;</span>。<br>示例 <span class="hljs-number">3</span>:<br><br>输入: deadends = [<span class="hljs-string">&quot;8887&quot;</span>,<span class="hljs-string">&quot;8889&quot;</span>,<span class="hljs-string">&quot;8878&quot;</span>,<span class="hljs-string">&quot;8898&quot;</span>,<span class="hljs-string">&quot;8788&quot;</span>,<span class="hljs-string">&quot;8988&quot;</span>,<span class="hljs-string">&quot;7888&quot;</span>,<span class="hljs-string">&quot;9888&quot;</span>], target = <span class="hljs-string">&quot;8888&quot;</span><br>输出：<span class="hljs-number">-1</span><br>解释：<br>无法旋转到目标数字且不被锁定。<br>示例 <span class="hljs-number">4</span>:<br><br>输入: deadends = [<span class="hljs-string">&quot;0000&quot;</span>], target = <span class="hljs-string">&quot;8888&quot;</span><br>输出：<span class="hljs-number">-1</span><br> <br><br>提示：<br><br><span class="hljs-number">1</span> &lt;= deadends.length &lt;= <span class="hljs-number">500</span><br>deadends[i].length == <span class="hljs-number">4</span><br>target.length == <span class="hljs-number">4</span><br>target 不在 deadends 之中<br>target 和 deadends[i] 仅由若干位数字组成<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liu yicheng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/6/25 - 21:49</span><br><span class="hljs-comment"> * 752. 打开转盘锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;<br><br>    String t, s;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(String[] _ds, String _t)</span> </span>&#123;<br>        s = <span class="hljs-string">&quot;0000&quot;</span>;<br>        t = _t;<br>        <span class="hljs-keyword">if</span> (s.equals(t)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (String d : _ds) set.add(d);<br>        <span class="hljs-keyword">if</span> (set.contains(s)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = bfs();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// d1 代表从起点 s 开始搜索（正向）</span><br>        <span class="hljs-comment">// d2 代表从结尾 t 开始搜索（反向）</span><br>        Deque&lt;String&gt; d1 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(), d2 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * m1 和 m2 分别记录两个方向出现的状态是经过多少次转换而来</span><br><span class="hljs-comment">         * e.g.</span><br><span class="hljs-comment">         * m1 = &#123;&quot;1000&quot;:1&#125; 代表 &quot;1000&quot; 由 s=&quot;0000&quot; 旋转 1 次而来</span><br><span class="hljs-comment">         * m2 = &#123;&quot;9999&quot;:3&#125; 代表 &quot;9999&quot; 由 t=&quot;9996&quot; 旋转 3 次而来</span><br><span class="hljs-comment">         */</span><br>        Map&lt;String, Integer&gt; m1 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(), m2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        d1.addLast(s);<br>        m1.put(s, <span class="hljs-number">0</span>);<br>        d2.addLast(t);<br>        m2.put(t, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 只有两个队列都不空，才有必要继续往下搜索</span><br><span class="hljs-comment">         * 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点</span><br><span class="hljs-comment">         * e.g.</span><br><span class="hljs-comment">         * 例如，如果 d1 为空了，说明从 s 搜索到底都搜索不到 t，反向搜索也没必要进行了</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> t = -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (d1.size() &lt;= d2.size()) &#123;<br>                t = update(d1, m1, m2);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                t = update(d2, m2, m1);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Deque&lt;String&gt; deque, Map&lt;String, Integer&gt; cur, Map&lt;String, Integer&gt; other)</span> </span>&#123;<br>        String poll = deque.pollFirst();<br>        <span class="hljs-keyword">char</span>[] pcs = poll.toCharArray();<br>        <span class="hljs-keyword">int</span> step = cur.get(poll);<br>        <span class="hljs-comment">// 枚举替换哪个字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-comment">// 能「正向转」也能「反向转」，这里直接枚举偏移量 [-1,1] 然后跳过 0</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = -<span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-comment">// 求得替换字符串 str</span><br>                <span class="hljs-keyword">int</span> origin = pcs[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">int</span> next = (origin + j) % <span class="hljs-number">10</span>;<br>                <span class="hljs-keyword">if</span> (next == -<span class="hljs-number">1</span>) next = <span class="hljs-number">9</span>;<br><br>                <span class="hljs-keyword">char</span>[] clone = pcs.clone();<br>                clone[i] = (<span class="hljs-keyword">char</span>)(next + <span class="hljs-string">&#x27;0&#x27;</span>);<br>                String str = String.valueOf(clone);<br><br>                <span class="hljs-keyword">if</span> (set.contains(str)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (cur.containsKey(str)) <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-comment">// 如果在「另一方向」找到过，说明找到了最短路，否则加入队列</span><br>                <span class="hljs-keyword">if</span> (other.containsKey(str)) &#123;<br>                    <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span> + other.get(str);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    deque.addLast(str);<br>                    cur.put(str, step + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="773-滑动谜题"><a href="#773-滑动谜题" class="headerlink" title="773. 滑动谜题"></a>773. 滑动谜题</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs lua">在一个 <span class="hljs-number">2</span> x <span class="hljs-number">3</span> 的板上（board）有 <span class="hljs-number">5</span> 块砖瓦，用数字 <span class="hljs-number">1</span>~<span class="hljs-number">5</span> 来表示, 以及一块空缺用 <span class="hljs-number">0</span> 来表示.<br><br>一次移动定义为选择 <span class="hljs-number">0</span> 与一个相邻的数字（上下左右）进行交换.<br><br>最终当板 board 的结果是 <span class="hljs-string">[[1,2,3],[4,5,0]]</span> 谜板被解开。<br><br>给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 <span class="hljs-number">-1</span> 。<br><br>示例：<br><br>输入：board = <span class="hljs-string">[[1,2,3],[4,0,5]]</span><br>输出：<span class="hljs-number">1</span><br>解释：交换 <span class="hljs-number">0</span> 和 <span class="hljs-number">5</span> ，<span class="hljs-number">1</span> 步完成<br>输入：board = <span class="hljs-string">[[1,2,3],[5,4,0]]</span><br>输出：<span class="hljs-number">-1</span><br>解释：没有办法完成谜板<br>输入：board = <span class="hljs-string">[[4,1,2],[5,0,3]]</span><br>输出：<span class="hljs-number">5</span><br>解释：<br>最少完成谜板的最少移动次数是 <span class="hljs-number">5</span> ，<br>一种移动路径:<br>尚未移动: <span class="hljs-string">[[4,1,2],[5,0,3]]</span><br>移动 <span class="hljs-number">1</span> 次: <span class="hljs-string">[[4,1,2],[0,5,3]]</span><br>移动 <span class="hljs-number">2</span> 次: <span class="hljs-string">[[0,1,2],[4,5,3]]</span><br>移动 <span class="hljs-number">3</span> 次: <span class="hljs-string">[[1,0,2],[4,5,3]]</span><br>移动 <span class="hljs-number">4</span> 次: <span class="hljs-string">[[1,2,0],[4,5,3]]</span><br>移动 <span class="hljs-number">5</span> 次: <span class="hljs-string">[[1,2,3],[4,5,0]]</span><br>输入：board = <span class="hljs-string">[[3,2,4],[1,5,0]]</span><br>输出：<span class="hljs-number">14</span><br>提示：<br><br>board 是一个如上所述的 <span class="hljs-number">2</span> x <span class="hljs-number">3</span> 的数组.<br>board[i][j] 是一个 [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] 的排列.<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liu yicheng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/6/26 - 8:51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *  可以使用双向 BFS</span><br><span class="hljs-comment">     *  一个向后搜索 一个向前搜索</span><br><span class="hljs-comment">     *   若是 重合 则为最短距离</span><br><span class="hljs-comment">     *   与 昨天的 题目 一样的解题思路</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *   需要将 二维 转换成 一维</span><br><span class="hljs-comment">     *   idx = 3 * x + y</span><br><span class="hljs-comment">     *   x = idx / 3</span><br><span class="hljs-comment">     *   y = idx % 3</span><br><span class="hljs-comment">     *   x 为 「横坐标」 y 为 「纵坐标」</span><br><span class="hljs-comment">     */</span><br><br>    String s, t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">slidingPuzzle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] board)</span> </span>&#123;<br>        t = <span class="hljs-string">&quot;123450&quot;</span>;<br>        s = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> n = board.length;<br>        <span class="hljs-comment">// 转换成字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span> m = board[i].length;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                s += board[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Objects.equals(s, t)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = bfs();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>        Deque&lt;String&gt; d1 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(), d2 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        Map&lt;String, Integer&gt; m1 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(), m2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        d1.addLast(s);<br>        m1.put(s, <span class="hljs-number">0</span>);<br>        d2.addLast(t);<br>        m2.put(t,<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">while</span> (!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> t = -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (d1.size() &lt;= d2.size()) &#123;<br>                t = update(d1, m1, m2);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                t = update(d2, m2, m1);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Deque&lt;String&gt; dq, Map&lt;String, Integer&gt; cur, Map&lt;String, Integer&gt; other)</span> </span>&#123;<br>        String poll = dq.pollFirst();<br>        <span class="hljs-keyword">char</span>[] ch = poll.toCharArray();<br>        <span class="hljs-keyword">int</span> step = cur.get(poll);<br><br>        <span class="hljs-comment">// 找到 &#x27;0&#x27; 所在的位置</span><br>        <span class="hljs-keyword">int</span> idx = poll.indexOf(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">int</span> x = idx / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> y = idx % <span class="hljs-number">3</span>;<br><br>        <span class="hljs-comment">// 交换 -3  -1 +1 +3 代表 上下左右 交换</span><br>        <span class="hljs-comment">// 需要判断 idx 是否有意义</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = -<span class="hljs-number">3</span>; j &lt;= <span class="hljs-number">3</span>; j += <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">int</span> t = idx + j;<br>            <span class="hljs-comment">// 防止 3 -&gt; 4 这种情况 x + 1, y 也 + 1, x, y 一次只能有一个加减一</span><br>            <span class="hljs-keyword">int</span> dx = t / <span class="hljs-number">3</span>, dy = t % <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">if</span> (dx != x &amp;&amp; dy != y) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">5</span> || t &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// idx 不合法</span><br><br>            <span class="hljs-comment">// idx 和 t 所在的字符进行交换</span><br>            <span class="hljs-keyword">char</span>[] clone = clone.clone();<br>            clone[idx] ^= clone[t];<br>            clone[t] ^= clone[idx];<br>            clone[idx] ^= clone[t];<br><br>            String str = String.valueOf(clone);<br><br>            <span class="hljs-keyword">if</span> (cur.containsKey(str)) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span> (other.containsKey(str)) &#123;<br>                <span class="hljs-keyword">return</span> step + other.get(str) + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dq.addLast(str);<br>                cur.put(str, step + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][] &#123;&#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        System.out.println(<span class="hljs-keyword">new</span> Test01().slidingPuzzle(data));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双向BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识面试整理总结</title>
    <link href="/2021/06/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <url>/2021/06/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><p>面试问题~</p><span id="more"></span><h2 id="一-java基础"><a href="#一-java基础" class="headerlink" title="一. java基础"></a>一. java基础</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.1</span> Hashmap 与 concurrentHashMap （重点）<br><span class="hljs-number">1.2</span> 集合相关问题<br><span class="hljs-number">1.3</span> Java 泛型的理解<br><span class="hljs-number">1.4</span> 跳表（ConcurrentSkipListMap）的查询过程是怎么样的，查询和插入的时间复杂度?<br><span class="hljs-number">1.5</span> java 字节流 字符流<br><span class="hljs-number">1.8</span> 包装类型和基本类型比较问题<br><span class="hljs-number">1.9</span> 为什么重写equals和hashcode<br><span class="hljs-number">1.10</span> stringBuilder和stringBuffer的区别<br><span class="hljs-number">1.11</span> Java序列化的原理<br><span class="hljs-number">1.11</span> Java8、<span class="hljs-number">9</span>、<span class="hljs-number">10</span>、<span class="hljs-number">11</span>的一些新特性介绍<br><span class="hljs-number">1.12</span> java中四种修饰符的限制范围。<br><span class="hljs-number">1.13</span> Object类中的方法。<br><span class="hljs-number">1.14</span> 浅拷贝 深拷贝<br><span class="hljs-number">1.15</span> 接口和抽象类的区别，注意JDK8的接口可以有实现。<br><span class="hljs-number">1.16</span> 动态代理的两种方式，以及区别。<br><span class="hljs-number">1.16</span> 传值和传引用的区别，Java是怎么样的，有没有传值引用。<br>    传值: 传递的是值的副本。方法中对副本的修改，不会影响到调用方。  如基本数据类型<br>    传引用: 传递的是引用的副本，共用一个内存，会影响到调用方。此时，形参和实参指向同一个内存地址。对引用副本本身（对象地址）的修改，如设置为<span class="hljs-keyword">null</span>，重新指向其他对象，不会影响到调用方。<br>        如 引用数据类型 <br>    传值引用: String 及 <span class="hljs-number">8</span>个包装类, 也不会对原来的值产生影响, 相当于传值引用<br>        <br><span class="hljs-number">1.17</span> 一个ArrayList在循环过程中删除，会不会出问题，为什么。<br>        使用<span class="hljs-keyword">for</span>循环正向 删除 list中连续重复的元素, 会发生遗漏   <br>        list.add(<span class="hljs-string">&quot;111&quot;</span>);<br>list.add(<span class="hljs-string">&quot;222&quot;</span>);<br>list.add(<span class="hljs-string">&quot;222&quot;</span>);<br>只会删除第一个<span class="hljs-string">&quot;222&quot;</span><br>        可以反向删除或者使用迭代器<br><span class="hljs-number">1.18</span> Exception和Error区别<br><span class="hljs-number">1.19</span> <span class="hljs-keyword">new</span>关键字和newinstance()方法<br><span class="hljs-number">1.20</span> Map、List、Set 分别说下你知道的线程安全类和线程不安全的类<br><span class="hljs-number">1.21</span> Java防止SQL注入<br><span class="hljs-number">1.22</span> 反射原理及使用场景<br><span class="hljs-number">1.23</span> <span class="hljs-keyword">static</span> Vs Final ？ 如何让类不能被继承<br><span class="hljs-number">1.24</span> 内存泄露？内存溢出？<br><span class="hljs-number">1.25</span> 重写Vs重载<br><span class="hljs-number">1.26</span> Lambda表达式实现<br><span class="hljs-number">1.27</span> ClassNotFoundException和NoClassDefFoundError的区别<br></code></pre></td></tr></table></figure><h2 id="二-并发、多线程"><a href="#二-并发、多线程" class="headerlink" title="二. 并发、多线程"></a>二. 并发、多线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2.1</span> <span class="hljs-keyword">volatile</span> 关键字 原理<br><span class="hljs-number">2.2</span> 对java中锁的理解<br><span class="hljs-number">2.3</span> 悲观锁 乐观锁<br><span class="hljs-number">2.4</span> 对CAS的理解，java中的CAS，如何不用unsafe实现CAS<br><span class="hljs-number">2.5</span> java 线程创建方式<br>线程run和start的区别？两次start同一个线程会怎么样？<br><span class="hljs-number">2.6</span> Java线程池的原理？线程池有哪些？线程池参数是什么？<br><span class="hljs-number">2.7</span> ThreadLocal及其应用场景<br><span class="hljs-number">2.8</span> 对线程安全的理解<br><span class="hljs-number">2.9</span> get需要加锁么，为什么？<br><span class="hljs-number">2.10</span> Lock的底层原理。<span class="hljs-keyword">synchronized</span>、Lock、ReentrantLock、ReadWriteLock。<br><span class="hljs-number">2.11</span> AtomicInteger怎么实现原子修改的？<br><span class="hljs-number">2.11</span> 分布式环境下，怎么保证线程安全。<br><span class="hljs-number">2.12</span> 产生死锁的四个必要条件？<br><span class="hljs-number">2.13</span> 如何中断线程<br><span class="hljs-number">2.14</span> 线程的状态都有哪些。<br><span class="hljs-number">2.15</span> wait、notify、notifyAll、await、signal、sleep、yield<br><span class="hljs-number">2.16</span> Callable和Future的了解。<br><span class="hljs-number">2.17</span> <span class="hljs-keyword">synchronized</span>关键字的用法，优缺点。<br><span class="hljs-number">2.18</span> 可重入锁的用处及实现原理，写时复制的过程，读写锁，分段锁<br><span class="hljs-number">2.19</span> ABC三个线程如何保证顺序执行。<br><span class="hljs-number">2.20</span> 双线程交替打印奇偶 （阿里）<br></code></pre></td></tr></table></figure><h2 id="三-JVM"><a href="#三-JVM" class="headerlink" title="三. JVM"></a>三. JVM</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">3.1</span> 常见GC算法、 CMS收集器、G1<br><span class="hljs-number">3.2</span> jvm内存模型 &amp;&amp; Java内存模型<br><span class="hljs-number">3.3</span> 怎么判断对象可被回收？GC 可达性分析中哪些算是GC ROOT？<br><span class="hljs-number">3.4</span> eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。<br><span class="hljs-number">3.4</span> fullgc是否可以回收方法区<br><span class="hljs-number">3.5</span> 什么对象会进老年代？ 为什么新生代使用复制算法？<br><span class="hljs-number">3.6</span> 被GC判断为<span class="hljs-string">&quot;垃圾&quot;</span>的对象一定会回收吗<br><span class="hljs-number">3.7</span> 强制young gc会有什么问题？<br><span class="hljs-number">3.8</span> 类加载的过程 Java为什么要设计双亲委派模型？<br><span class="hljs-number">3.9</span> 什么时候会触发minor gc，什么时候会触发full gc？<br><span class="hljs-number">3.10</span> G1和ZGC的区别<br><span class="hljs-number">3.12</span> 你知道强引用、弱引用和软引用吗? GC对他们执行怎样的操作。<br><span class="hljs-number">3.13</span> JVM方法栈的工作过程，方法栈和本地方法栈有什么区别。<br><span class="hljs-number">3.14</span> JVM的栈中引用如何和堆中的对象产生关联。<br><span class="hljs-number">3.15</span> 逃逸分析技术。<br><span class="hljs-number">3.16</span> Java是否可以GC直接内存。<br><span class="hljs-number">3.17</span> 常用的JVM调优参数。<br><span class="hljs-number">3.6</span> 具体的性能调优步骤吗？fullgc的时候会导致接口的响应速度特别慢，该如何排查和解决。<br><span class="hljs-number">3.18</span> dump文件的分析。<br><span class="hljs-number">3.19</span> Java有没有主动触发GC的方式<br><span class="hljs-number">3.20</span> 假如现在在同一台机器上开两个java项目，有几个java虚拟机？<br><span class="hljs-number">3.21</span> javac编译期工作流程<br></code></pre></td></tr></table></figure><h2 id="四-Spring"><a href="#四-Spring" class="headerlink" title="四. Spring"></a>四. Spring</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">4.1</span> spring IOC 过程<br><span class="hljs-number">4.2</span> 循环依赖怎么解决的<br><span class="hljs-number">4.3</span> spring AOP，动态代理是怎么实现的<br><span class="hljs-number">4.4</span> spring BeanDefinition作用<br><span class="hljs-number">4.5</span> spring <span class="hljs-meta">@Autowired</span> (<span class="hljs-meta">@Resource</span>, 类似）实现原理<br><span class="hljs-number">4.6</span> bean的生命周期<br><span class="hljs-number">4.7</span> Bean的默认作用范围是什么？其他的作用范围？<br><span class="hljs-number">4.8</span> Spring的单例是怎么实现的？<br><span class="hljs-number">4.11</span> SpringMVC不同用户登录的信息怎么保证线程安全的？<br><span class="hljs-number">4.12</span> Spring用了哪些设计模式。<br><span class="hljs-number">4.13</span> Spring注入bean的方式。<br><span class="hljs-number">4.14</span> 什么是IOC，什么是依赖注入。<br><span class="hljs-number">4.15</span> Spring具有什么特点（IOC和AOP）<br><span class="hljs-number">4.16</span> 几种scope区别，aop实现有哪几种实现，<br><span class="hljs-number">4.17</span> spring的事务及实现模式<br><span class="hljs-number">4.19</span> 对Spring、SpringMVC、springBoot理解<br><span class="hljs-number">4.20</span> <span class="hljs-meta">@transactional</span>注解在什么情况下会失效，为什么。<br><span class="hljs-number">4.21</span> SpringMVC的Controller是如何将参数和前端传来的数据一一对应的。<br><span class="hljs-number">4.23</span> Spring如何维护它拥有的bean。<br><span class="hljs-number">4.24</span> 自定义注解的实现。<br><span class="hljs-number">4.25</span> 如何自己设计IOC框架<br><span class="hljs-number">4.26</span> Quartz是如何完成定时任务的。<br><span class="hljs-number">4.18</span> servlet的生命周期，怎么判断是get请求还是post请求，后台实现session共享的方法。Java web过滤器的生命周期？过滤器和拦截器的区别。<br><span class="hljs-number">4.19</span> BeanFactory 和 FactoryBean 的区别<br><span class="hljs-number">4.20</span> Spring中配置id或name相同的Bean可能引发的问题及解决方案<br><span class="hljs-number">4.21</span> 防止Web表单重复提交的方法<br></code></pre></td></tr></table></figure><h2 id="五-消息中间件"><a href="#五-消息中间件" class="headerlink" title="五. 消息中间件"></a>五. 消息中间件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">5.1</span> kafka有哪些组件，kafka controller选举过程，kafka leader重选举过程<br><span class="hljs-number">5.2</span> kafka 最早是为了解决什么问题设计的<br><span class="hljs-number">5.3</span> 为什么kafka用zookeeper来存储metadata，而不是用db来存储<br><span class="hljs-number">5.4</span> kafka 只有一次生产 只有一次消费怎么做<br><span class="hljs-number">5.5</span> kafka的消费模式？kafka怎么做有序消费？kafka 重消费解决？消息丢失怎么解决？<br><span class="hljs-number">5.6</span> Kafka的Replicas的作用？<br></code></pre></td></tr></table></figure><h2 id="六-算法"><a href="#六-算法" class="headerlink" title="六. 算法"></a>六. 算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">6.1</span> B+树<br><span class="hljs-number">6.2</span> hash和B+树的区别？分别应用于什么场景？哪个比较好？<br><span class="hljs-number">6.3</span> 红黑树了解么，时间复杂度? 五个特性<br><span class="hljs-number">6.4</span> 堆排序的时间复杂度<br><span class="hljs-number">6.5</span> 快速排序，堆排序，插入排序<br><span class="hljs-number">6.6</span> 一致性Hash算法，一致性Hash算法的应用<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode - 1239. 串联字符串的最大长度</title>
    <link href="/2021/06/22/LeetCode-1239-%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/"/>
    <url>/2021/06/22/LeetCode-1239-%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<hr><ol start="1239"><li>串联字符串的最大长度 (中等难度)</li></ol><span id="more"></span><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。</p><p>请返回所有可行解 s 中最长长度。</p><p>示例 1：</p><p>输入：arr = [“un”,”iq”,”ue”]<br>输出：4<br>解释：所有可能的串联组合是 “”,”un”,”iq”,”ue”,”uniq” 和 “ique”，最大长度为 4。<br>示例 2：</p><p>输入：arr = [“cha”,”r”,”act”,”ers”]<br>输出：6<br>解释：可能的解答有 “chaers” 和 “acters”。<br>示例 3：</p><p>输入：arr = [“abcdefghijklmnopqrstuvwxyz”]<br>输出：26</p><p>提示：</p><p>1 &lt;= arr.length &lt;= 16<br>        1 &lt;= arr[i].length &lt;= 26<br>        arr[i] 中只含有小写英文字母</p><h3 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h3><ul><li><p>题目要求每个字符只能出现一次,所以可以先对字符串数组 arr 进行去重, 去除出现重复字符的字符串</p></li><li><p>可以使用  <strong>dfs</strong> 爆搜  </p><p>​                                可分为两种情况:     1. 使用当前字符串</p><p>​                                                                 2. 不使用当前字符串 </p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] hash;<br>    <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-keyword">int</span> ans;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(List&lt;String&gt; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// 首先对 arr 进行去重</span><br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">int</span> n = arr.size();<br><br>        out:<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            String s = arr.get(i);<br>            <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;    <span class="hljs-comment">// val 26位, 每次偏移对应字符的距离,如果为 1,则说明该字符已经存在</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>                <span class="hljs-keyword">int</span> t = c - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 偏移量</span><br>                <span class="hljs-keyword">if</span> ((val &gt;&gt; t &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span> out; <span class="hljs-comment">// 说明该字符串出现了重复的数字</span><br>                val |= (<span class="hljs-number">1</span> &lt;&lt; t);  <span class="hljs-comment">// 记录对应的字符</span><br>            &#125;<br>            set.add(val);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 存入数组, 便于查找</span><br>        len = set.size();<br>        hash = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>, total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer i : set) &#123;<br>            hash[idx++] = i;<br>            total |= i;  <span class="hljs-comment">// 总共有多少1, 即字符的种类有多少</span><br>        &#125;<br>        <br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, total);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        u   当前的数组下标</span><br><span class="hljs-comment">        cur 当前的所有1代表的值</span><br><span class="hljs-comment">        left 剩余可选的1代表的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> left)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == len) &#123;<br>            ans = Math.max(ans, get(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果能选当前字符</span><br>        <span class="hljs-keyword">if</span> ((hash[u] &amp; cur) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 没有重复的字符</span><br>            dfs(u + <span class="hljs-number">1</span>, cur | hash[u], left - (left &amp; hash[u]));<br>        &#125;<br>        <span class="hljs-comment">// 不能选</span><br>        dfs(u + <span class="hljs-number">1</span>, cur, left);<br>    &#125;<br>    <br>    <br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(); <span class="hljs-comment">// 记忆数组, 加快查询速度</span><br>    <span class="hljs-comment">/* 获取int中 1 的个数, 即字符的个数 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(x)) <span class="hljs-keyword">return</span> map.get(x);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 使用 lowbit 来求 1 的个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i != <span class="hljs-number">0</span>; i -= (i &amp; -i)) ans++;<br>        map.put(x, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode 刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-剑指 Offer 38. 字符串的排列</title>
    <link href="/2021/06/22/LeetCode-%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2021/06/22/LeetCode-%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<hr><p>剑指 Offer 第38题  字符串的所有排列组合问题</p><span id="more"></span><p>题目如下:</p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><p>输入：s = “abc”<br>        输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>限制：</p><p>1 &lt;= s 的长度 &lt;= 8</p><h3 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h3><p>这是求该字符串所有可能的排列组合, 对于这类问题可以用回溯来列出所有的可能.</p><p>题目要求,不能重复,我们可以使用Set来去重</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> annotion.Medium;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liu yicheng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/6/22 - 12:11</span><br><span class="hljs-comment"> * 剑指 Offer 38. 字符串的排列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> N = <span class="hljs-number">10</span>;  <span class="hljs-comment">// s 的长度不超过 10</span><br>    <span class="hljs-keyword">boolean</span>[] isChoosed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[N];  <span class="hljs-comment">// 用于检验字符是否已经被选择</span><br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-meta">@Medium</span><br>    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>        Arrays.fill(isChoosed, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">char</span>[] ch = s.toCharArray();<br>        dfs(ch, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">int</span> n = set.size();<br>        String[] ans = <span class="hljs-keyword">new</span> String[n];<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (String str : set) ans[idx++] = str;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *  ch s的字符数组</span><br><span class="hljs-comment">     *  u  当前下标</span><br><span class="hljs-comment">     *  cur 当前拼接成的字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] ch, <span class="hljs-keyword">int</span> u, String cur)</span> </span>&#123;<br>        <span class="hljs-comment">// 结束条件</span><br>        <span class="hljs-keyword">int</span> n = ch.length;<br>        <span class="hljs-keyword">if</span> (u == n) &#123;<br>            set.add(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 选择字符添加到 cur 中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!isChoosed[i]) &#123;   <span class="hljs-comment">// 如果没有选择过</span><br>                isChoosed[i] = <span class="hljs-keyword">true</span>;<br>                dfs(ch, u + <span class="hljs-number">1</span>, cur + String.valueOf(ch[i]));<br>                System.out.println(cur);<br>                isChoosed[i] = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String test = <span class="hljs-string">&quot;ansd&quot;</span>;<br>        System.out.println(<span class="hljs-keyword">new</span> Test01().permutation(test));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试总结-Day0616</title>
    <link href="/2021/06/16/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-Day0616/"/>
    <url>/2021/06/16/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-Day0616/</url>
    
    <content type="html"><![CDATA[<p>总的来说还是基础不扎实,还是得先好好巩固java基础</p><hr><span id="more"></span><p>题目:</p><ul><li>@bean 和 @component 两个注解的区别</li><li>java 动态代理</li><li>MySQL 索引</li><li>java原生注解</li><li>http报文包含哪些内容</li><li>Mybatis 怎么保存枚举类</li><li>Threadlocal</li><li>Servlet</li></ul><h3 id="Bean-和-Component"><a href="#Bean-和-Component" class="headerlink" title="@Bean 和 @Component"></a>@Bean 和 @Component</h3><p>相同: 两者都是为容器中添加组件</p><p>而不同的是, Component是系统在组件扫描时自动配置的,而bean注解可以由我们自己进行精准的配置,各个属性.</p><h3 id="Http报文有哪些内容"><a href="#Http报文有哪些内容" class="headerlink" title="Http报文有哪些内容"></a>Http报文有哪些内容</h3><p><img src="http%E6%8A%A5%E6%96%87.png" alt="http报文"></p><h3 id="java注解"><a href="#java注解" class="headerlink" title="java注解"></a>java注解</h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><ul><li><p>元注解:  可以对注解进行注解</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented :"></a>@Documented :</h4><p>被@Documented 标注的注解 会被写到javadoc中</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>描述注解的生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RetentionPolicy</span> </span>&#123;<br><br>    SOURCE,    <span class="hljs-comment">// 源文件保留</span><br>    CLASS,       <span class="hljs-comment">// 编译期保留，默认值</span><br>    RUNTIME   <span class="hljs-comment">// 运行期保留，可通过反射去获取注解信息</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>​    描述注解的作用域</p><p>​    例如:</p><p>​    <img src="/2021/06/16/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-Day0616/override.png" alt="Override"></p><p>Override 注解的作用域是方法,只能在方法上标注Override</p><p>public enum ElementType {</p><pre><code>TYPE, // 类、接口、枚举类 FIELD, // 成员变量（包括：枚举常量） METHOD, // 成员方法 PARAMETER, // 方法参数 CONSTRUCTOR, // 构造方法 LOCAL_VARIABLE, // 局部变量 ANNOTATION_TYPE, // 注解类 PACKAGE, // 可用于修饰：包 TYPE_PARAMETER, // 类型参数，JDK 1.8 新增 TYPE_USE // 使用类型的任何地方，JDK 1.8 新增&#125;</code></pre><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>被@Inherited标注的注解具有继承性</p></li></ul><ul><li><p><strong>作用在代码的注解是</strong></p><ul><li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul></li><li><p>当然也可以自定义注解</p></li></ul><p><font color="red"><strong>注解的作用: 使用注解可以更好地解释程序,例如有很多方法需要测试,需要分周期完成,我可以自定义一个@Finish注解来标记已经测试完成的内容</strong></font></p><h3 id="Mybatis-怎么简化枚举类的存取"><a href="#Mybatis-怎么简化枚举类的存取" class="headerlink" title="Mybatis 怎么简化枚举类的存取"></a>Mybatis 怎么简化枚举类的存取</h3><p>Mybatis提供有typehandler</p><p><a href="https://blog.csdn.net/weixin_34162695/article/details/88923919">https://blog.csdn.net/weixin_34162695/article/details/88923919</a></p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><a href="https://aobing.blog.csdn.net/article/details/116431270">https://aobing.blog.csdn.net/article/details/116431270</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC总结回顾</title>
    <link href="/2021/06/15/SpringMVC%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/06/15/SpringMVC%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<hr><p>主要总结和回顾之前学习的SpringMVC,捡起以前的东西,温故而知新~~~</p><span id="more"></span><h3 id="首先什么是MVC"><a href="#首先什么是MVC" class="headerlink" title="首先什么是MVC"></a>首先什么是MVC</h3><p><strong>M</strong>: 即model, 模型层,  主要是数据</p><p><strong>V</strong>:  即View,  视图层, 页面视图</p><p><strong>C</strong>: 即Controller, 控制层, 处理前端的请求</p><h2 id="MVC的工作流程"><a href="#MVC的工作流程" class="headerlink" title="MVC的工作流程"></a>MVC的工作流程</h2><h3 id="One-请求的分发"><a href="#One-请求的分发" class="headerlink" title="One.  请求的分发"></a>One.  请求的分发</h3><ul><li><p>前端浏览器发来的请求, 会到DispatcherServlet这里进行统一的分发处理</p></li><li><p>它会遍历所有的HandlerMappings(处理器映射关系),这里的Handler就是Controller中的一个个方法,</p><p>每一个方法就是一个Handler</p></li><li><p>找到能够处理这个请求的Handler和所有的拦截器</p></li><li><p>执行拦截器的PreHandle方法,对请求进行过滤</p></li><li><p>接着生成Handler的Adapter适配器</p></li><li><p>由适配器去执行目标方法</p></li></ul><h3 id="Two-目标方法的执行"><a href="#Two-目标方法的执行" class="headerlink" title="Two. 目标方法的执行"></a>Two. 目标方法的执行</h3><h4 id="1-解析参数"><a href="#1-解析参数" class="headerlink" title="1.解析参数"></a>1.解析参数</h4><p>顾名思义,要执行目标方法,首先得获得方法的参数.</p><ul><li><p>对于每一个参数,都会遍历所有的参数解析器,找到能够处理这种类型的参数解析器,调用Converter,将String转成需要的类型</p></li><li><p>对于自定义类型的参数, 也有专门的解析器,<strong>ServletModelAttributeMethodProcessor</strong> </p><p><strong>WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</strong></p><p><strong>WebDataBinder :web数据绑定器，将请求参数的值绑定到指定的JavaBean里面</strong></p><p><strong>WebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中</strong></p><p><strong>GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型（JavaBean – Integer）</strong></p><p><strong>byte – &gt; file</strong></p></li></ul><h4 id="2-执行目标方法-获得返回值"><a href="#2-执行目标方法-获得返回值" class="headerlink" title="2. 执行目标方法,获得返回值"></a>2. 执行目标方法,获得返回值</h4><p>所有的数据会被放在ModelAndView这个对象中,如果返回页面,也会保存页面的地址值</p><h3 id="Three-返回值的处理"><a href="#Three-返回值的处理" class="headerlink" title="Three. 返回值的处理"></a>Three. 返回值的处理</h3><h4 id="1-返回值处理器"><a href="#1-返回值处理器" class="headerlink" title="1. 返回值处理器"></a>1. 返回值处理器</h4><p>遍历所有的返回值处理器,找到能够处理相应数据类型的返回值处理器</p><h4 id="2-数据响应-响应数据-和-响应页面"><a href="#2-数据响应-响应数据-和-响应页面" class="headerlink" title="2.数据响应 (响应数据 和 响应页面)"></a>2.数据响应 (响应数据 和 响应页面)</h4><p><img src="/2021/06/15/SpringMVC%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE/mvc.png" alt="mvc"></p><p><font color="red"><strong>内容协商</strong></font></p><p>确定数据以什么形式传给浏览器</p><p>过程:</p><h5 id="1-确定浏览器接受什么样的媒体类型"><a href="#1-确定浏览器接受什么样的媒体类型" class="headerlink" title="1.确定浏览器接受什么样的媒体类型"></a>1.确定浏览器接受什么样的媒体类型</h5><p>基于浏览器参数方式的内容协商方式和基于请求头的内容协商方式</p><p>以基于请求头的内容协商方式为例,浏览器会将其所能接受的类型以请求头的方式传给服务器,服务器将其取出,放入集合A中</p><h5 id="2-确定服务器能够生产的所有媒体类型"><a href="#2-确定服务器能够生产的所有媒体类型" class="headerlink" title="2.确定服务器能够生产的所有媒体类型"></a>2.确定服务器能够生产的所有媒体类型</h5><p><strong>MessageConverter</strong> 主要包含5个方法</p><p>CanRead() canWrite() read() write() 还有支持转换的媒体类型</p><p>遍历所有的MessageConverters,找出所有能够支持处理该种返回值类型的所有MessageConverter所能处理的所有媒体类型,把他们放在集合B中</p><h5 id="3-最佳匹配"><a href="#3-最佳匹配" class="headerlink" title="3.最佳匹配"></a>3.最佳匹配</h5><p>将集合A与集合B做一个最佳匹配,确定一个返回的媒体类型</p><h5 id="4-再次遍历"><a href="#4-再次遍历" class="headerlink" title="4. 再次遍历"></a>4. 再次遍历</h5><p>再次遍历所有的MessageConverters,找出所有能够将返回值类型转换成确定的这种媒体类型的MessageConverter,调用它将数据转换成需要的媒体类型.</p><h4 id="3-响应页面"><a href="#3-响应页面" class="headerlink" title="3. 响应页面"></a>3. 响应页面</h4><ul><li>首先还是遍历所有的返回值处理器,找到能够处理页面的返回值处理器</li><li>利用视图解析器将ModelAndView中的view视图地址解析出来</li><li>调用Render函数将model中的数据渲染到页面中</li><li>返回页面</li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux之JDK安装</title>
    <link href="/2021/06/14/linux%E4%B9%8BJDK%E5%AE%89%E8%A3%85/"/>
    <url>/2021/06/14/linux%E4%B9%8BJDK%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<hr><span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>rpm安装jdk,配置环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC之有趣的一题</title>
    <link href="/2021/06/14/LC%E4%B9%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%80%E9%A2%98/"/>
    <url>/2021/06/14/LC%E4%B9%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><p>魔法之Rust：蔡勒公式  哈哈哈哈</p><span id="more"></span><h2 id="one-常规思路"><a href="#one-常规思路" class="headerlink" title="one. 常规思路"></a>one. 常规思路</h2><ul><li><p>我们知道1971年1月1日为周五, 那么我们可以它作为基点, 求出所求的时间到它的距离,在和7取模,就是答案</p></li><li><p>上代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dayOfTheWeek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> day, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> year)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先枚举出每个月的天数, 先忽略闰年</span><br>        <span class="hljs-keyword">int</span>[] mons = &#123;<span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">13</span>];<br>    <span class="hljs-comment">// 求出前缀和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) sum[i] = sum[i - <span class="hljs-number">1</span>] + mons[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 需要减去1971年1月1日这天</span><br>        <span class="hljs-keyword">int</span> days = (year - <span class="hljs-number">1971</span>) * <span class="hljs-number">365</span> + sum[month - <span class="hljs-number">1</span>] + day - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 看是否为闰年</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1971</span>; i &lt;= year; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; i % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || i % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果所求的年份不超过2月,则不受闰年的影响</span><br>                <span class="hljs-keyword">if</span> (i &lt; year || (year == i &amp;&amp; month &gt; <span class="hljs-number">2</span>)) &#123;<br>                    days ++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        String[] week = &#123;<span class="hljs-string">&quot;Saturday&quot;</span>, <span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>&#125;;<br>    <span class="hljs-comment">// 需要向右偏移6个单位, 因为是以星期五为基点, 但枚举的week是按照西方的习惯枚举的,所有需要进行偏移</span><br>        <span class="hljs-keyword">int</span> idx = (<span class="hljs-number">6</span> + days) % <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">return</span> week[idx];<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>总的来说,还是比较简单的,但是还是有许多细节,细节很重要</p><ol><li>求天数的时候,需要减去 1971.1.1 这天,总和需要减一</li><li>是否为闰年</li><li>枚举week时, 不同的顺序需要进行偏移!!!  默认week[0]应该为Friday</li></ol></li></ul><h2 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h2><ul><li><p>前人总结出了公式,所以可以直接套用</p></li><li><p>公式如下:</p><p><img src="/2021/06/14/LC%E4%B9%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%80%E9%A2%98/gongshi.png" alt="公式"></p></li><li><p>需要注意的是: <font color="red"><strong>如果月份是一月或者二月, year需要减一, month需要加12</strong></font></p><p>枚举week要从<font color="red"><strong>Saturday</strong></font>开始,否则要进行偏移</p></li><li><p>上代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dayOfTheWeek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> day, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> year)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (month &lt;= <span class="hljs-number">2</span>) &#123;<br>           month += <span class="hljs-number">12</span>;<br>           year -= <span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span> n = (day + <span class="hljs-number">13</span> * (month + <span class="hljs-number">1</span>) / <span class="hljs-number">5</span> + year + year / <span class="hljs-number">4</span> - year / <span class="hljs-number">100</span> + year / <span class="hljs-number">400</span>) % <span class="hljs-number">7</span>;<br>       String[] week = &#123;<span class="hljs-string">&quot;Saturday&quot;</span>, <span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>&#125;;<br>       <span class="hljs-keyword">return</span> week[n];<br>   &#125;<br>  <br></code></pre></td></tr></table></figure></li><li><p>哈哈哈不愧是魔法呀~</p><p><img src="/2021/06/14/LC%E4%B9%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%80%E9%A2%98/mofa.png" alt="魔法"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>LC-1185. 一周中的第几天</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux总结</title>
    <link href="/2021/06/12/linux%E6%80%BB%E7%BB%93/"/>
    <url>/2021/06/12/linux%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><p>linux 操作大全,哈哈哈哈~</p><span id="more"></span><h3 id="准则-linux中没有错误就是成功"><a href="#准则-linux中没有错误就是成功" class="headerlink" title="准则: linux中没有错误就是成功"></a><font color="blue">准则: linux中没有错误就是成功</font></h3><h3 id="1-开关机"><a href="#1-开关机" class="headerlink" title="1.开关机"></a>1.开关机</h3><ul><li><p>sync 关机前 将内存中的数据写入磁盘</p></li><li><p>shutdown  -h now 现在强制关机</p></li><li><p>shutdown -h 10  10分钟后关机</p></li><li><p>shutdown -r now 立即重启</p></li><li><p>shutdown -r +10 10分钟后重启</p></li><li><p>reboot 重启 等于shutdown -r now</p></li><li><p>halt 关闭系统  等于 shutdown -h now 和 poweroff</p></li></ul><h3 id="2-目录相关操作"><a href="#2-目录相关操作" class="headerlink" title="2.目录相关操作"></a>2.目录相关操作</h3><p><font color="red"> <strong>1.一切皆为文件</strong></font></p><p><font color="red"><strong>2.根目录 / ,所有文件都挂载在这个节点下</strong></font></p><ul><li><p><strong>ls /</strong>   </p><p>查看目录下的所有文件</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/ls.png" alt="示例1"></p></li><li><p>ls: 列出目录</p></li><li><p>cd：切换目录</p></li><li><p>pwd：显示目前的目录</p></li><li><p>mkdir：创建一个新的目录</p></li><li><p>rmdir：删除一个空的目录</p></li><li><p>cp: 复制文件或目录</p></li><li><p>rm: 移除文件或目录</p></li><li><p>mv: 移动文件与目录，或修改文件与目录的名称</p></li><li><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp</p></li></ul><blockquote><p>ls （列出目录）</p></blockquote><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls [-aAdfFhilnrRSt] 目录名称</span><br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls -al ~</span><br></code></pre></td></tr></table></figure><blockquote><p>cd （切换目录）</p></blockquote><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span><span class="hljs-meta"> [相对路径或绝对路径]</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 切换到用户目录下</span><br>[root<span class="hljs-symbol">@kuangshen</span> /]<span class="hljs-meta"># cd home  </span><br><br><span class="hljs-meta"># 使用 mkdir 命令创建 kuangstudy 目录</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># mkdir kuangstudy</span><br><br><span class="hljs-meta"># 进入 kuangstudy 目录</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># cd kuangstudy</span><br><br><span class="hljs-meta"># 回到上一级</span><br>[root<span class="hljs-symbol">@kuangshen</span> kuangstudy]<span class="hljs-meta"># cd ..</span><br><br><span class="hljs-meta"># 回到根目录</span><br>[root<span class="hljs-symbol">@kuangshen</span> kuangstudy]<span class="hljs-meta"># cd /</span><br><br><span class="hljs-meta"># 表示回到自己的家目录，亦即是 /root 这个目录</span><br>[root<span class="hljs-symbol">@kuangshen</span> kuangstudy]<span class="hljs-meta"># cd ~</span><br></code></pre></td></tr></table></figure><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><blockquote><p>pwd ( 显示目前所在的目录 )</p></blockquote><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[root@kuangshen kuangstudy]</span><span class="hljs-selector-id">#pwd</span> <span class="hljs-selector-attr">[-P]</span><br></code></pre></td></tr></table></figure><p>选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。</p><p>测试：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 单纯显示出目前的工作目录</span><br>[root<span class="hljs-symbol">@kuangshen</span> ~]<span class="hljs-meta"># pwd</span><br>/root<br><br><span class="hljs-meta"># 如果是链接，要显示真实地址，可以使用 -P参数</span><br>[root<span class="hljs-symbol">@kuangshen</span> /]<span class="hljs-meta"># cd bin</span><br>[root<span class="hljs-symbol">@kuangshen</span> bin]<span class="hljs-meta"># pwd -P</span><br>/usr/bin<br></code></pre></td></tr></table></figure><blockquote><p>mkdir （创建新目录）</p></blockquote><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir [-mp] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>测试：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># 进入我们用户目录下</span><br>[root@kuangshen /]<span class="hljs-comment"># cd /home</span><br><br><span class="hljs-comment"># 创建一个 test 文件夹</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir test</span><br><br><span class="hljs-comment"># 创建多层级目录</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir test1/test2/test3/test4</span><br>mkdir: cannot create directory ‘test1/test2/test3/test4’:<br>No such file or directory  <span class="hljs-comment"># &lt;== 没办法直接创建此目录啊！</span><br><br><span class="hljs-comment"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir -p test1/test2/test3/test4</span><br><br><span class="hljs-comment"># 创建权限为 rwx--x--x 的目录。</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir -m 711 test2</span><br>[root@kuangshen home]<span class="hljs-comment"># ls -l</span><br>drwxr-xr-x<span class="hljs-number"> 2 </span>root root <span class="hljs-number"> 4096 </span>Mar<span class="hljs-number"> 12 </span>21:55 test<br>drwxr-xr-x<span class="hljs-number"> 3 </span>root root <span class="hljs-number"> 4096 </span>Mar<span class="hljs-number"> 12 </span>21:56 test1<br>drwx--x--x<span class="hljs-number"> 2 </span>root root <span class="hljs-number"> 4096 </span>Mar<span class="hljs-number"> 12 </span>21:58 test2<br></code></pre></td></tr></table></figure><blockquote><p>rmdir ( 删除空的目录 )</p></blockquote><p>语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmdir [-p] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p><p>测试：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># 看看有多少目录存在？</span><br>[root@kuangshen home]<span class="hljs-comment"># ls -l</span><br>drwxr-xr-x<span class="hljs-number"> 2 </span>root root <span class="hljs-number"> 4096 </span>Mar<span class="hljs-number"> 12 </span>21:55 test<br>drwxr-xr-x<span class="hljs-number"> 3 </span>root root <span class="hljs-number"> 4096 </span>Mar<span class="hljs-number"> 12 </span>21:56 test1<br>drwx--x--x<span class="hljs-number"> 2 </span>root root <span class="hljs-number"> 4096 </span>Mar<span class="hljs-number"> 12 </span>21:58 test2<br><br><span class="hljs-comment"># 可直接删除掉，没问题</span><br>[root@kuangshen home]<span class="hljs-comment"># rmdir test</span><br><br><span class="hljs-comment"># 因为尚有内容，所以无法删除！</span><br>[root@kuangshen home]<span class="hljs-comment"># rmdir test1</span><br>rmdir: failed to remove ‘test1’: Directory not empty<br><br><span class="hljs-comment"># 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span><br>[root@kuangshen home]<span class="hljs-comment"># rmdir -p test1/test2/test3/test4</span><br></code></pre></td></tr></table></figure><p>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会将！</p><blockquote><p>cp ( 复制文件或目录 )</p></blockquote><p>语法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[root@www ~]</span># <span class="hljs-selector-tag">cp</span> <span class="hljs-selector-attr">[-adfilprsu]</span> 来源档(source) 目标档(destination)<br><span class="hljs-selector-attr">[root@www ~]</span># <span class="hljs-selector-tag">cp</span> <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-tag">source1</span> <span class="hljs-selector-tag">source2</span> <span class="hljs-selector-tag">source3</span> .... <span class="hljs-selector-tag">directory</span><br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>测试：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 找一个有文件的目录，我这里找到 root目录</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># cd /root</span><br>[root<span class="hljs-symbol">@kuangshen</span> ~]<span class="hljs-meta"># ls</span><br>install.sh<br>[root<span class="hljs-symbol">@kuangshen</span> ~]<span class="hljs-meta"># cd /home</span><br><br><span class="hljs-meta"># 复制 root目录下的install.sh 到 home目录下</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># cp /root/install.sh /home</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># ls</span><br>install.sh<br><br><span class="hljs-meta"># 再次复制，加上-i参数，增加覆盖询问？</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># cp -i /root/install.sh /home</span><br>cp: overwrite ‘/home/install.sh’? y <span class="hljs-meta"># n不覆盖，y为覆盖</span><br></code></pre></td></tr></table></figure><blockquote><p>rm ( 移除文件或目录 )</p></blockquote><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">rm <span class="hljs-selector-attr">[-fir]</span> 文件或目录<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><p>测试：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><br>[root@kuangshen home]<span class="hljs-comment"># rm -i install.sh</span><br>rm: <span class="hljs-keyword">remove</span> regular <span class="hljs-keyword">file</span> ‘<span class="hljs-keyword">install</span>.sh’? y<br><span class="hljs-comment"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><br><br><span class="hljs-comment"># 尽量不要在服务器上使用 rm -rf /</span><br></code></pre></td></tr></table></figure><blockquote><p>mv  ( 移动文件与目录，或修改名称 )</p></blockquote><p>语法：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># mv [-fiu] source destination</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># mv [options] source1 source2 source3 .... directory</span><br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>测试：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 复制一个文件到当前目录</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># cp /root/install.sh /home</span><br><br><span class="hljs-meta"># 创建一个文件夹 test</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># mkdir test</span><br><br><span class="hljs-meta"># 将复制过来的文件移动到我们创建的目录，并查看</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># mv install.sh test</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># ls</span><br>test<br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># cd test</span><br>[root<span class="hljs-symbol">@kuangshen</span> test]<span class="hljs-meta"># ls</span><br>install.sh<br><br><span class="hljs-meta"># 将文件夹重命名，然后再次查看！</span><br>[root<span class="hljs-symbol">@kuangshen</span> test]<span class="hljs-meta"># cd ..</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># mv test mvtest</span><br>[root<span class="hljs-symbol">@kuangshen</span> home]<span class="hljs-meta"># ls</span><br>mvtest<br><br><br></code></pre></td></tr></table></figure><h2 id="3-文件操作"><a href="#3-文件操作" class="headerlink" title="3.文件操作"></a>3.文件操作</h2><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/dir.png" alt="目录"></p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/dirmod.png" alt="文件权限"></p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/mod.png" alt="权限"></p><h4 id="chgrp-R-root-www-将www所在目录及其子文件的所属组改为root-R-表示所在目录及其子文件"><a href="#chgrp-R-root-www-将www所在目录及其子文件的所属组改为root-R-表示所在目录及其子文件" class="headerlink" title="chgrp -R root www    将www所在目录及其子文件的所属组改为root   -R  表示所在目录及其子文件"></a>chgrp -R root www    将www所在目录及其子文件的所属组改为root   -R  表示所在目录及其子文件</h4><h4 id="chown-R-root-www-将www所在目录及其子文件的所有者改为root"><a href="#chown-R-root-www-将www所在目录及其子文件的所有者改为root" class="headerlink" title="chown -R root www   将www所在目录及其子文件的所有者改为root"></a>chown -R root www   将www所在目录及其子文件的所有者改为root</h4><h4 id="chmod-更改文件权限"><a href="#chmod-更改文件权限" class="headerlink" title="chmod  更改文件权限"></a>chmod  更改文件权限</h4><p>chmod 777 lyc</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/setmod.png" alt="权限设置"></p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/filecheck.png" alt="文件查看"></p><p><strong>网络配置目录</strong></p><p>cd /etc/sysconfig/network-scripts</p><p><strong>查看网络配置</strong></p><h4 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h4><p>cat  / tac  正/反 查看文件内容</p><p>nl  查看行号</p><p>ifconfig</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/nl.png" alt="查看文件内容带行号"></p><p>more命令  一页一页显示文件内容 (空格进行翻页, enter代表向下翻一行 :f 行号, </p><p>退出 q命令 , /xxx 向下查找字符串 , ?xxxx 向上查找, n代表继续搜寻下一个, N代表向上查找上一个</p><p>)</p><p>less比more增加了向前翻动页面  使用上下键</p><p>head 只看头几行  head -n 20 xxxx.xx 通过 -n参数来控制行数</p><p>tail 只看尾巴几行</p><h2 id="4-硬链接和软连接"><a href="#4-硬链接和软连接" class="headerlink" title="4.硬链接和软连接"></a>4.硬链接和软连接</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>A —&gt; B     B 是A的一个硬链接, A被删除,A仍能访问B的内容, A的内容改变,B的内容也会跟着改变, 允许一个文件拥有多个路径,防止误删~         <font color="red"><strong>硬链接创建的是文件</strong></font></p><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><p>相当于超链接,当源文件被删除后,不能再访问</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote><p><strong>ln</strong>  创建连接</p></blockquote><ul><li><p>使用  touch 命令创建文件</p><p>例如: 创建一个文件 f1</p><p>touch f1</p></li><li><p>给f1创建一个硬链接f2</p><p>ln f1 f2  (f1,f2内容相同, f1内容改变,f2也会变,f1被删除,f2仍能显示f1的内容)</p></li><li><p>给f1创建一个软连接(类似于超链接)</p><p><font color="red"><strong>f1,f2是实体文件,f3类似于一个超链接,不是文件</strong></font>&gt;</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/link.png" alt="创建连接"></p></li><li><p>给f1源文件输入字符串</p><p>echo “xxx” &gt;&gt;f1</p><p><strong>可以发现f2,f3中都显示了f1中的内容</strong></p></li></ul><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/write.png" alt="输入内容"></p><p><strong>尝试删除份f1</strong></p><p>rm -rf f1   (-rf表示递归强制删除)</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/rmf1.png" alt="删除f1"></p><p><font color="red"><strong>由图中可以看出,删除f1后,f3的软连接失效,而f2依旧存在</strong></font></p><p>而输入  cat f3 则报错, 说明软连接失效~~</p><p><font color="red"><strong>因此备份文件可以通过创建硬链接来实现</strong></font></p><h2 id="5-vim编辑器"><a href="#5-vim编辑器" class="headerlink" title="5.vim编辑器"></a>5.vim编辑器</h2><h3 id="三种模式-命令模式-输入模式-底线命令模式"><a href="#三种模式-命令模式-输入模式-底线命令模式" class="headerlink" title="三种模式: 命令模式, 输入模式, 底线命令模式"></a><font color="red">三种模式: 命令模式, 输入模式, 底线命令模式</font></h3><p>vim  xxxx</p><p>进入vim编辑器后,默认是命令模式</p><ul><li><p>输入 <strong>i</strong>,切换到输入模式</p></li><li><p>输入 <strong>x</strong>,删除当前光标所在的字符</p></li><li><p>输入 <strong>:</strong>     , 进入底线命令模式,输入<font color="red"><strong>wq</strong></font>  保存退出. </p><p>​            如果是输入模式要进入底线命令模式进行保存退出, 首先按ESC,退出输入模式,在输入wq. </p></li></ul><p><font color="red"><strong>快捷方式:</strong></font></p><p>底线命令模式:  :w  保存    :q退出  :w!强制保存 :q!强制退出  :set nu 显示行号</p><h2 id="6-用户管理"><a href="#6-用户管理" class="headerlink" title="6.用户管理"></a>6.用户管理</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>useradd 选项 用户名</p><p>useradd -m lyc</p><p>-m : 表示自动创建这个用户的主目录,  比如这条语句执行后  会在home 目录下生成  lyc的文件夹,  所有有关lyc的文件都会存放在该目录</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/params.png" alt="参数说明"></p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/useradd.png" alt="创建用户"></p><p>-G: 给用户分配组</p><p><font color="red"><strong>linux中,一切皆是文件,所以创建用户,就是创建文件来保存用户信息</strong></font></p><p>/etc/passwd中有用户的密码信息</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/passwd.png" alt="密码信息"></p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>userdel -r 用户名</p><p>userdel -r lyc</p><h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><p>usermod</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/params.png" alt="参数说明"></p><p>usermod -d /home/233 lyc</p><p>修改完成后查看配置文件即可</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><h4 id="su-用户名"><a href="#su-用户名" class="headerlink" title="su 用户名"></a>su 用户名</h4><p>切换到lyc用户 :   su lyc </p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/root.png" alt="root用户"></p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/others.png" alt="其他用户"></p><p>切换完成后,使用 <strong>exit</strong>退回root用户目录</p><h4 id="查看主机名-hostname"><a href="#查看主机名-hostname" class="headerlink" title="查看主机名  hostname"></a>查看主机名  hostname</h4><p>修改主机名为duedne :  hostname duende 修改完成重新连接即可</p><h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><p>passwd lyc   —-修改lyc的密码</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/changepasswd.png" alt="修改密码"></p><p>超级用户可以修改任何人的密码</p><p>普通用户只能修改自己的密码</p><h4 id="锁定用户"><a href="#锁定用户" class="headerlink" title="锁定用户"></a>锁定用户</h4><p>passwd -l 用户名   锁定后,该用户不能登录</p><h2 id="7-用户组管理"><a href="#7-用户组管理" class="headerlink" title="7. 用户组管理"></a>7. 用户组管理</h2><p>首先回顾一下,修改文件的用户组操作  —-  chgrp -R xxx (修改到哪个用户组)  xxx(需要修改的文件名称)</p><p>用户组涉及用户的增加,删除,修改.</p><p><font color="red"><strong>组的增加,删除和修改实际上就是对/etc/group文件进行更新</strong></font></p><h3 id="创建一个用户组"><a href="#创建一个用户组" class="headerlink" title="创建一个用户组"></a>创建一个用户组</h3><p>groupadd lyc</p><p>cat /etc/group</p><p>创建完成可以去/etc/group文件下查看</p><p><strong>groupadd -g 520 lyc2 指定组的id</strong>     不指定id,id默认会自增</p><h3 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h3><p>groupdel lyc2</p><h3 id="修改用户组的权限-信息和名字"><a href="#修改用户组的权限-信息和名字" class="headerlink" title="修改用户组的权限,信息和名字"></a>修改用户组的权限,信息和名字</h3><p>groupmod -n newName  原组名称  ———更换组名称   </p><p>groupmod -g  newid  原组名称 ———–更换组id </p><h3 id="切换用户组"><a href="#切换用户组" class="headerlink" title="切换用户组"></a>切换用户组</h3><p>newgrp  [新的组名称]</p><h2 id="8-磁盘管理"><a href="#8-磁盘管理" class="headerlink" title="8. 磁盘管理"></a>8. 磁盘管理</h2><h3 id="df命令-列出文件系统整体的磁盘使用量"><a href="#df命令-列出文件系统整体的磁盘使用量" class="headerlink" title="df命令(列出文件系统整体的磁盘使用量)"></a>df命令(列出文件系统整体的磁盘使用量)</h3><ul><li>df</li></ul><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/df.png" alt="df"></p><ul><li>df -h   <font color="red"><strong>以M为单位显示</strong></font></li></ul><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/df-h.png" alt="df-h"></p><h3 id="du命令-检查磁盘空间使用量"><a href="#du命令-检查磁盘空间使用量" class="headerlink" title="du命令(检查磁盘空间使用量)"></a>du命令(检查磁盘空间使用量)</h3><ul><li><p>du命令</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/du.png" alt="du"></p></li><li><p>du -a 查看包含隐藏文件的使用量</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/du-a.png" alt="du-a"></p></li></ul><p><strong>ls -a</strong>也是如此,可以列出隐藏文件</p><ul><li><p><font color="blue"><strong>检查根目录下所有文件的容量</strong></font></p><p>du -sm /*</p><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/du-sm.png" alt="du -sm /*"></p></li></ul><h3 id="挂载-mount命令-了解"><a href="#挂载-mount命令-了解" class="headerlink" title="挂载: mount命令(了解)"></a>挂载: mount命令(了解)</h3><p>将外部设备挂载到某一个目录下</p><p>mount /dev/lyc1 /mnt/lyc2</p><p>解释: 将外部设备lyc1挂载到lyc2目录下</p><h3 id="卸载-unmount-f命令-了解"><a href="#卸载-unmount-f命令-了解" class="headerlink" title="卸载: unmount -f命令(了解)"></a>卸载: unmount -f命令(了解)</h3><p>unmount -f [挂载位置]</p><h2 id="9-进程管理"><a href="#9-进程管理" class="headerlink" title="9.进程管理"></a>9.进程管理</h2><h3 id="Q-什么是进程"><a href="#Q-什么是进程" class="headerlink" title="Q: 什么是进程?"></a>Q: 什么是进程?</h3><ul><li>在linux中,每一个程序都有一个自己的进程,二=而每一个进程都有一个id号</li><li>每一个进程都有一个父进程</li><li>进程有两种存在方式: 前台  || 后台   运行</li><li>一般来说,服务都是后台运行,基本的程序都是前台运行</li></ul><h3 id="PS命令"><a href="#PS命令" class="headerlink" title="PS命令"></a>PS命令</h3><p><font color="blue" size="5"><strong>查看当前系统中正在执行的各种进程信息</strong></font></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h4><ul><li>-a   显示当前终端运行的所有的进程信息</li><li>-u   以用户的信息显示进程</li><li>-x   显示后台运行的进程参数      </li></ul><p><font color="red"><strong>在linux中  |  表示管道符</strong></font></p><p><font color="red"><strong>grep 表示查找文件中符合条件的字符串</strong></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有的进程</span><br>ps -aux|grep<br><span class="hljs-comment"># 这条命令很常用</span><br><br><span class="hljs-comment"># 比如查看mysql相关的所有进程</span><br>ps -aux|grep mysql<br>ps -aux|grep java<br></code></pre></td></tr></table></figure><p><font color="red"><strong>目前只需要记住 ps -xx|grep 进程名字</strong></font></p><p><font color="red"><strong>ps -ef|grep 可以通过此命令查看父进程信息</strong></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef|grep mysql<br></code></pre></td></tr></table></figure><p><font color="red"><strong>也可以通过目录树结构来查看</strong></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pstree -pu<br>-p 显示父id<br>-u 显示用户组<br></code></pre></td></tr></table></figure><p><img src="/2021/06/12/linux%E6%80%BB%E7%BB%93/pstree.png" alt="pstree"></p><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><h4 id="kill-9-进程id"><a href="#kill-9-进程id" class="headerlink" title="kill -9   [进程id]"></a>kill -9   [进程id]</h4><p>例如: kill  -9  99312     表示杀死进程号为99312的进程</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git总结</title>
    <link href="/2021/06/12/git%E6%80%BB%E7%BB%93/"/>
    <url>/2021/06/12/git%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><p>git一些常用的操作命令~~~</p><span id="more"></span><h3 id="one-基本命令"><a href="#one-基本命令" class="headerlink" title="one. 基本命令"></a>one. 基本命令</h3><ol><li><p>​    <strong>git config -l</strong></p><p><img src="/2021/06/12/git%E6%80%BB%E7%BB%93/git-config-l.png" alt="git基本命令"></p><p>查看所有的配置</p></li><li><p>  <strong>git conifg –system –list</strong></p></li></ol><p>   查看系统配置</p><ol start="3"><li> <strong>git config –global –list</strong> </li></ol><p>   查看本地配置</p><p>   git config – global user.name    配置用户名</p><p>   git config – global user.email     配置密码</p><p>   (PS: 用户名和密码是必须要配置的)</p><h3 id="two-基本原理"><a href="#two-基本原理" class="headerlink" title="two. 基本原理"></a>two. 基本原理</h3><p><img src="/2021/06/12/git%E6%80%BB%E7%BB%93/gitcore.png" alt="git原理"></p><h5 id="Remote-Directory-远程仓库"><a href="#Remote-Directory-远程仓库" class="headerlink" title="Remote Directory:   远程仓库"></a>Remote Directory:   远程仓库</h5><h5 id="History-Repository-本地仓库"><a href="#History-Repository-本地仓库" class="headerlink" title="History(Repository):  本地仓库"></a>History(Repository):  本地仓库</h5><h5 id="Stage-Index-暂存区"><a href="#Stage-Index-暂存区" class="headerlink" title="Stage(Index):  暂存区"></a>Stage(Index):  暂存区</h5><h5 id="Working-Directory-工作区"><a href="#Working-Directory-工作区" class="headerlink" title="Working Directory: 工作区"></a>Working Directory: 工作区</h5><h5 id="流程"><a href="#流程" class="headerlink" title="流程:"></a>流程:</h5><h5 id="工作区-gt-git-add-gt-暂存区-gt-git-commit-gt-本地仓库-gt-git-push"><a href="#工作区-gt-git-add-gt-暂存区-gt-git-commit-gt-本地仓库-gt-git-push" class="headerlink" title="工作区 -&gt; git add -&gt; 暂存区 -&gt; git commit -&gt; 本地仓库 -&gt; git push"></a>工作区 -&gt; git add -&gt; 暂存区 -&gt; git commit -&gt; 本地仓库 -&gt; git push</h5><h5 id="gt-远程仓库"><a href="#gt-远程仓库" class="headerlink" title="-&gt; 远程仓库"></a>-&gt; 远程仓库</h5><hr><h3 id="three-操作命令"><a href="#three-操作命令" class="headerlink" title="three.操作命令"></a>three.操作命令</h3><ul><li><p>生成git项目 {</p><p>​                            I.    git init   (自己生成)</p><p>​                            II.  git clone  [url]   (克隆远程git项目)</p></li><li><p><img src="/2021/06/12/git%E6%80%BB%E7%BB%93/gitstatus.png" alt="查看文件状态"></p><p> 查看文件状态</p></li><li><p>git add .  添加所有文件到暂存区   </p><p>git  rm   取消添加到暂存区</p></li><li><p>git commit -m “msg”   将暂存区内容添加到本地仓库</p><p>git check out 取消添加到本地仓库</p></li><li><p>git push -u origin main 提交到远程仓库</p></li><li><p><img src="/2021/06/12/git%E6%80%BB%E7%BB%93/gitignore1.png" alt="忽略文件"></p><p><img src="/2021/06/12/git%E6%80%BB%E7%BB%93/gitignore2.png" alt="常用设置"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#为注释 *.txt       </span><br><span class="hljs-comment">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br>!lib.txt     <span class="hljs-comment">#但lib.txt除外</span><br>/temp        <span class="hljs-comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br>build<span class="hljs-regexp">/       #忽略build/</span>目录下的所有文件<br>doc<span class="hljs-regexp">/*.txt    #会忽略 doc/</span>notes.txt 但不包括 doc<span class="hljs-regexp">/server/</span>arch.txt<br></code></pre></td></tr></table></figure><h3 id="four-IDEA集成Git"><a href="#four-IDEA集成Git" class="headerlink" title="four.IDEA集成Git"></a>four.IDEA集成Git</h3><ul><li>将远程仓库中的git项目拷贝到目录即可</li></ul><h3 id="five-Git分支"><a href="#five-Git分支" class="headerlink" title="five.Git分支"></a>five.Git分支</h3><p>列出所有本地分支                    git branch<br>列出所有远程分支                    git branch -r<br>新建一个分支，但依然停留在当前分支     git branch [branch-name]<br>新建一个分支，并切换到该分支          git checkout -b [branch]<br>合并指定分支到当前分支               git merge [branch]<br>删除分支                             git branch -d [branch-name]<br>删除远程分支  git push origin –delete [branch-name]</p><p>​                        git branch -dr [remote/branch]</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于6月的规划</title>
    <link href="/2021/06/12/%E5%85%B3%E4%BA%8E6%E6%9C%88%E7%9A%84%E8%A7%84%E5%88%92/"/>
    <url>/2021/06/12/%E5%85%B3%E4%BA%8E6%E6%9C%88%E7%9A%84%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<hr><p>关于今年6月的一些规划和学习目标~~~~</p><span id="more"></span><hr><h3 id="一-工作方面"><a href="#一-工作方面" class="headerlink" title="一. 工作方面"></a>一. 工作方面</h3><pre><code>    1. 加强面试, 锻炼技巧,找到一份真正合适的工作    2. 谈薪~</code></pre><p>​        </p><h3 id="二-学习方面"><a href="#二-学习方面" class="headerlink" title="二. 学习方面"></a>二. 学习方面</h3><pre><code>    1. java基础学习巩固    2. linux入门    3. leetcode 刷题    4. 自己写一个小项目 (Springboot + Vue)</code></pre><hr><h3 id="三-生活方面"><a href="#三-生活方面" class="headerlink" title="三.生活方面"></a>三.生活方面</h3><pre><code>        1. 早睡早起,不熬夜        2. 每天吃早饭!</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>短期规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客的搭建(Hexo)</title>
    <link href="/2018/07/31/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2018/07/31/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>简单介绍hexo的安装及基本操作</p><span id="more"></span><h2 id="Step-one-安装"><a href="#Step-one-安装" class="headerlink" title="Step one. 安装"></a>Step one. 安装</h2><p>1.首先安装hexo   cnpm install -g hexo-cli  (node.js)</p><p>2.mkdir blog  创建文件夹</p><p>3.执行hexo init </p><p>4.启动博客 hexo s (hexo start)</p><hr><h2 id="Step-two-新建文章"><a href="#Step-two-新建文章" class="headerlink" title="Step two. 新建文章"></a>Step two. 新建文章</h2><p>使用  hexo new “xxx” 命令</p><p>写完文章后</p><p>hexo clean  </p><p>hexo g –生成</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
